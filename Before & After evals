#==============================================================================
# â–¼ Blesstama - Before/After Evals v0.1
# -----------------------------------------------------------------------------
# Actor/Class/Item/Skill/Weapon/Enemy/State Notetags:
# These notetags go in the X notebox in the database.
# -----------------------------------------------------------------------------
# <Before Before Eval>
#    COMMAND
# </Before Befroe Eval>
# <Before Eval>
#    COMMAND
# </Before Eval>
# <After Eval>
#    COMMAND
# </After Eval>
# Using this note makes anything inside it trigger command
# after item has did own thing where the COMMAND is any valid ruby thing.
# You can use the following variables in your command:
#     user - the current enemy/actor
#     item - skill/item that was used
#     p - game party
#     t - game troop
#     v - game variables (v[10] for variable 10)
#     s - game switches (s[15] for switch[15])
# Keep in mind that before^2 variation triggers only once +
# you are uncapable of using self/b for it, while before/after evals
# repeated as much times as much skill hits + you can use self/b.
# <state apply>
#    COMMAND
# </state apply>
# <state update>
#    COMMAND
# </state update>
# <state remove>
#    COMMAND
# </state remove>
# <battle start>
#    COMMAND
# </battle start>
# <turn start>
#    COMMAND
# </turn start>
# <turn end>
#    COMMAND
# </turn end>
# <battle end>
#    COMMAND
# </battle end>
# Same variables as before^2 but triggers when:
# 1)you apply state
# 2)every time state duration decreases by 1
# 3)state is removed
# 4)battle started, happens once per, well, battle
# 5)turn start aka when player selected his moves
# 6)turn end aka after all actions was performed
# 7)battle end, happens once in, well, end (win lose or escape, not matter)
# keep in mind that options 1-3 works only on state note itself, while 4-7 follows normal rules
#le examples:
# <Before Eval>
# return if !self.result.hit?
# user.hp += 100
# </Before Eval>

# user of skill will restores 100 hp if his action was successful
#(no evasion, no misses and no counters)

# <After Eval>
# if user != self
#   drain = self.mp >= 100 ? 100 : self.mp
#   user.mp += drain
#   self.mp -= 100
# end
# </After Eval>
#
# user of skill will drain 100 mp from target as long as he has on
#(if less than 100 mp then drain what left)

# <Before Eval>
# if item.repeats >= 3
#  user.tp += 2
# else
#  user.tp += 5
# end
# </Before Eval>
# if currently used item has more or equal 3, give 2 tp per it, else 5

#<state update>
# s = [2,3,6]
# 2.times do
#  user.add_debuff(s.sample,4) 
# end
#</state update>
# every time state loses duration add 2 random atk/def/agi debuff to user.

#<battle start>
# return if user.death_state?
# user.force_action(996, 0)
# BattleManager.force_action(user)
#</battle start>
#at start of any battle user will execute skill 996 unless he is dead.

# -----------------------------------------------------------------------------
class Scene_Battle < Scene_Base
  alias :pre_item :use_item
  def use_item
    item = @subject.current_action.item
    pre_skill_eval(@subject, item)
    pre_item
  end
  
  def pre_skill_eval(user, item)
    regexp = /<Before Before Eval>(.*?)<\/Before Before Eval>/im
    item.note.scan(regexp).each do |code|
      eval_command(user, item, code.first)
    end
    user.get_all_notes.scan(regexp).each do |code|
      eval_command(user, item, code.first)
    end
  end
  
  def eval_command(user, item, formula, b=self, p=$game_party, s=$game_switches, t=$game_troop, v=$game_variables)
    eval(formula)
  rescue Exception => e
    puts "Error in Before/After Eval: #{e.message}"
  end
end


module BattleManager
  
  class << self
    alias :base_battle_start :battle_start
    alias :base_start :turn_start
    alias :base_end :turn_end
	alias :base_battle_end :battle_start_end
  end
 def self.battle_start
   base_battle_start
   regexp = /<battle start>(.*?)<\/battle start>/im
   all = []
   all += $game_party.members
   all += $game_troop.members
   all.each do |user|
     user.turnhandle(user, regexp)
   end
 end
 def self.turn_start
   regexp = /<turn start>(.*?)<\/turn start>/im
   all = []
   all += $game_party.members
   all += $game_troop.members
   all.each do |user|
    user.turnhandle(user, regexp)
   end
   base_start
 end
 def self.turn_end
   regexp = /<turn end>(.*?)<\/turn end>/im
   all = []
   all += $game_party.members
   all += $game_troop.members
   all.each do |user|
    user.turnhandle(user, regexp)
   end
   base_end
 end
  def self.battle_end(result)
   regexp = /<battle end>(.*?)<\/battle end>/im
   all = []
   all += $game_party.members
   all += $game_troop.members
   all.each do |user|
    user.turnhandle(user, regexp)
   end
   base_battle_end
  end
end

class Game_Battler < Game_BattlerBase
  
  alias itemsapplied item_apply
  def item_apply(user, item)
    regexp = /<Before Eval>(.*?)<\/Before Eval>/im
    itemevals(user, item, regexp)
    itemsapplied(user, item)
    regexp = /<After Eval>(.*?)<\/After Eval>/im
    itemevals(user, item, regexp)
  end
  
  alias base_addstate add_state
  def add_state(state_id)
    regexp = /<state apply>(.*?)<\/state apply>/im
    statehandle(self, state_id, regexp) if state_addable?(state_id)
    base_addstate(state_id)
  end

  alias base_turnupdate update_state_turns
  def update_state_turns
    regexp = /<state update>(.*?)<\/state update>/im
    states.each do |state|
      puts "state id: #{state.id}"
      statehandle(self, state.id, regexp)
    end
    base_turnupdate
  end
  
  alias base_erasestate erase_state
  def erase_state(state_id)
    regexp = /<state remove>(.*?)<\/state remove>/im
    statehandle(self, state_id, regexp) if state?(state_id)
    base_erasestate(state_id)
  end

  def statehandle(user, state_id, regexp)
    $data_states[state_id].note.scan(regexp).each do |code|
      puts "triggered"
      eval_command(user, $data_states[state_id], code.first)
    end
  end
  
  def itemevals(user, item, regexp)
    item.note.scan(regexp).each do |code|
      eval_command(user, item, code.first)
    end
    user.get_all_notes.scan(regexp).each do |code|
      eval_command(user, item, code.first)
    end
  end
  
  def turnhandle(user, regexp)
    user.get_all_notes.scan(regexp).each do |code|
      eval_command(user, item = nil, code.first)
    end
  end
  

  def eval_command(user, item, formula, b=self, p=$game_party, s=$game_switches, t=$game_troop, v=$game_variables)
    eval(formula)
  rescue Exception => e
    puts "Error in Before/After Eval: #{e.message}"
  end

end
