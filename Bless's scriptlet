#EVERYTHING BELOW THIS IS FREE TO ADD IT JUST GIVES NEW FEATURES/REWRITES FOR GOOD
#--------------------------------------------------------------------------
# * Ability to pick all notes from actor and enemy (mandatory for some of my scripts)
#--------------------------------------------------------------------------
class Game_Enemy < Game_Battler
  def note
    enemy.note.to_s
  end
  def get_all_notes(*args)
    notes = ""
    notes += note unless args.include?(:self)
    states.compact.each { |state| notes += state.note } unless args.include?(:state)
    notes
  end
end

class Game_Actor < Game_Battler
  def note
    actor.note.to_s
  end

  def get_all_notes(*args)
    notes = ""
    notes += note unless args.include?(:self)
    notes += self.class.note unless args.include?(:class)
    equips.compact.each { |equip| notes += equip.note } unless args.include?(:equip)
    states.compact.each { |state| notes += state.note } unless args.include?(:state)
    notes
  end
end
#--------------------------------------------------------------------------
# * Ability to do log messages in battle/map (also mandatory for few)
#--------------------------------------------------------------------------
class Scene_Battle < Scene_Base 
  attr_accessor:log_window
end

class Scene_Map < Scene_Base 
  attr_accessor:log_window
end
#--------------------------------------------------------------------------
# * Code stuff
#--------------------------------------------------------------------------
class Object
  def rand_between(min, max)
    min + rand(max - min + 1)
  end
end
#--------------------------------------------------------------------------
# * Buffs Add-On
#--------------------------------------------------------------------------
class Game_Battler < Game_BattlerBase	
  #--------------------------------------------------------------------------
  # * Check if battler has any buffed parameters
  #--------------------------------------------------------------------------
  def buffed?
    @buffs.any? { |param| param > 0 }
  end
  #--------------------------------------------------------------------------
  # * Check if battler has any debuffed parameters
  #--------------------------------------------------------------------------
  def debuffed?
    @buffs.any? { |param| param < 0 }
  end
  #--------------------------------------------------------------------------
  # * Add Buff (Stage Based)
  #--------------------------------------------------------------------------
  def add_buffs(param_id, turns, size)
    return unless alive?
    @buffs[param_id] += size unless buff_max?(param_id)
    erase_buff(param_id) if debuff?(param_id)
    overwrite_buff_turns(param_id, turns)
    @result.added_buffs.push(param_id).uniq!
    refresh
  end
  #--------------------------------------------------------------------------
  # * Add Debuff (Stage Based)
  #--------------------------------------------------------------------------
  def add_debuffs(param_id, turns, size)
    return unless alive?
    size = 1 if size.is_a? == true
    @buffs[param_id] -= size unless debuff_max?(param_id)
    erase_buff(param_id) if buff?(param_id)
    overwrite_buff_turns(param_id, turns)
    @result.added_debuffs.push(param_id).uniq!
    refresh
  end
end
#--------------------------------------------------------------------------
# * Manipulations with enemy
#--------------------------------------------------------------------------
class Game_Enemy < Game_Battler
  #--------------------------------------------------------------------------
  # * Change image he use (use name from Battlers folder)
  #--------------------------------------------------------------------------
  def swapimage(name)
    @battler_name = name
  end
  #--------------------------------------------------------------------------
  # * Change name
  #--------------------------------------------------------------------------
  def swapname(name)
    @original_name = name
  end
  #--------------------------------------------------------------------------
  # * Change hue
  #--------------------------------------------------------------------------
  def swaphue(number)
    @battler_hue = number
  end
end
#--------------------------------------------------------------------------
# * Allows function Change Battleback work in battle
#--------------------------------------------------------------------------
class Game_Interpreter
  alias_method :command_283_orig_kal, :command_283
  def command_283
	 command_283_orig_kal
	 if SceneManager.scene.is_a?(Scene_Battle)
	   scene = SceneManager.scene
	   scene.spriteset.change_image(@params[0], @params[1])
	 end
  end
end
class Scene_Battle
  attr_reader :spriteset
end
class Spriteset_Battle
  def change_image(name, name2)
    @back1_sprite.bitmap = Bitmap.new("Graphics/Battlebacks1/#{name}.png")
    @back2_sprite.bitmap = Bitmap.new("Graphics/Battlebacks1/#{name2}.png")
    @back1_sprite.z = 0
    center_sprite(@back1_sprite)
    update
  end
end
#--------------------------------------------------------------------------
# * Overwrites script call command to not crash game + give small hint on where it died
#--------------------------------------------------------------------------
class Game_Interpreter
  alias stockscript command_355
  def command_355
    stockscript
    rescue Exception => error
      puts "marshal: #{marshal_dump[3]}"
      puts "Map id: #{marshal_dump[1]}"
      puts "Event id: #{marshal_dump[2]}"
      puts "Common event id: #{$game_temp.common_event_id}"
      puts "Script call: #{@list[@index].parameters[0]}"
      puts "page: #{@page}"
      puts "code line: #{@list[@index].parameters}"
      puts "What happened: #{error}"
  end
end
#EVERYTHING BELOW THIS IS OVERWRITES/DEBATABLE CHANGES
#--------------------------------------------------------------------------
# * Atk Speed Fix (all skills have atk speed bonus and not just skill 1)
#--------------------------------------------------------------------------
class Game_Action
  def speed
    speed = subject.agi + rand(5 + subject.agi / 4)
    speed += item.speed if item
    speed += subject.atk_speed if item.is_a?(RPG::Skill)
    speed
  end
end	
#--------------------------------------------------------------------------
# * Skill Rating alterating by accepting all ratings (no 100% ones)
#--------------------------------------------------------------------------
class Game_Enemy < Game_Battler
  def make_actions
    super
    return if @actions.empty?
    action_list = enemy.actions.select {|a| action_valid?(a) }
    return if action_list.empty?
    rating_max = action_list.collect {|a| a.rating }.max
    #rating_zero = rating_max - 3 (old nae nae way)
    rating_zero = -1
    action_list.reject! {|a| a.rating <= rating_zero }
    @actions.each do |action|
      action.set_enemy_action(select_enemy_action(action_list, rating_zero))
    end
  end
  #--------------------------------------------------------------------------
  # Alters enemy select to make that it will 100% use skills with rating 10 (for charge attacks)
  #--------------------------------------------------------------------------
  def select_enemy_action(action_list, rating_zero)
    sum = action_list.inject(0) {|r, a| r += a.rating - rating_zero }
    max = action_list.collect {|a| a.rating }.max
    if max >= 10
      action_list.reject! { |skill| skill.rating < 9 }
      puts "list: #{action_list}"
      return action_list.sample
    end
    return nil if sum <= 0
    value = rand(sum)
    action_list.each do |action|
      return action if value < action.rating - rating_zero
      value -= action.rating - rating_zero
    end
  end	
end
#--------------------------------------------------------------------------
# * Substitute Buff
#--------------------------------------------------------------------------
class Scene_Battle < Scene_Base
  def check_substitute(target, item)
    target.hp < target.mhp / 2 && (!item || !item.certain?)
  end
end
class Game_Battler < Game_BattlerBase
  #--------------------------------------------------------------------------
  # * Overwrites LUK formula to make it better and balanced
  #--------------------------------------------------------------------------
  def luk_effect_rate(user)
    if user.luk - luk > 0
      [1.0 + (user.luk - luk) * 0.0025, 2.5].min
    else
      [1.0 + (user.luk - luk) * 0.002, 0.1].max
    end
  end
end
